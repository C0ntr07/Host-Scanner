#include "VulnerabilityLookup.h"
#include "DataReader.h"
#include <mutex>

using namespace std;
using namespace boost;

vector<struct CveEntry*> VulnerabilityLookup::entries = vector<struct CveEntry*>();

vector<CveEntry*> VulnerabilityLookup::Scan(const string& cpe)
{
	if (entries.size() == 0)
	{
		loadEntries();
	}

	vector<CveEntry*> matches;

	if (cpe.length() == 0)
	{
		return matches;
	}

	for (auto i = 0u; i < entries.size(); i++)
	{
		if (entries[i]->affected.find(cpe) != entries[i]->affected.end())
		{
			matches.push_back(entries[i]);
		}
	}

	return matches;
}

unordered_map<string, vector<CveEntry*>> VulnerabilityLookup::Scan(const vector<string>& cpes)
{
	if (entries.size() == 0)
	{
		loadEntries();
	}

	unordered_map<string, vector<CveEntry*>> matches;

	if (cpes.size() == 0)
	{
		return matches;
	}

	for (auto i = 0u; i < entries.size(); i++)
	{
		for (auto cpe : cpes)
		{
			if (entries[i]->affected.find(cpe) != entries[i]->affected.end())
			{
				matches[cpe].push_back(entries[i]);
			}
		}
	}

	return matches;
}

vector<CveEntry*> VulnerabilityLookup::GetEntries()
{
	if (entries.size() == 0)
	{
		loadEntries();
	}

	return entries;
}

void VulnerabilityLookup::loadEntries()
{
	static mutex mtx;
	auto locked = mtx.try_lock();
	if (!locked)
	{
		// wait until running parser finishes before returning
		lock_guard<mutex> guard(mtx);
		return;
	}

	// open entries file

	DataReader dr;

	if (!dr.OpenEnv("cve-list"))
	{
		log(WRN, "CVE database was not found!");

		mtx.unlock();
		return;
	}

	unsigned short ptype, pver;

	dr.Read(ptype);
	dr.Read(pver);

	if (ptype != 5)
	{
		log(WRN, "CVE database type is incorrect.");

		mtx.unlock();
		return;
	}

	if (pver != 1)
	{
		log(WRN, "CVE database version is not supported.");

		mtx.unlock();
		return;
	}

	unsigned int pnum;
	dr.Read(pnum);

	for (auto i = 0u; i < pnum; i++)
	{
		auto ent = new CveEntry();

		unsigned char fnum;
		dr.Read(fnum); // TODO deprecate

		ent->cve = dr.ReadString();

		unsigned char sevhi, sevlo;
		dr.Read(sevhi);
		dr.Read(sevlo);

		ent->severity = sevhi + (float(sevlo) / 10);

		unsigned short vnum;
		dr.Read(vnum); // TODO change to int

		ent->affected = unordered_set<string>();

		for (auto j = 0u; j < vnum; j++)
		{
			ent->affected.emplace(dr.ReadString());
		}

		entries.push_back(ent);
	}

	// clean up

	mtx.unlock();
}

VulnerabilityLookup::~VulnerabilityLookup()
{
}
