#include "VulnerabilityLookup.h"
#include "Utils.h"
#include <mutex>
#include <boost/filesystem.hpp>

using namespace std;
using namespace boost;
namespace fs = boost::filesystem;

vector<CveEntry> VulnerabilityLookup::Scan(const string& cpe)
{
	vector<CveEntry> matches;

	if ((db == nullptr && !openDatabase()) || cpe.empty() || count(cpe.begin(), cpe.end(), ':') < 3)
	{
		return matches;
	}

	sqlite3_stmt *stmt;
	const char *err = nullptr;

	auto rc = sqlite3_prepare_v2(db, "select cve, cpe, date, descr, severity, access from affected join vulns on vulns.id = affected.vuln_id where cpe like ? or cpe like ? order by id desc", -1, &stmt, &err);

	if (rc != SQLITE_OK)
	{
		log(ERR, "Failed to prepare statement: " + string(err));

		delete err;
		return matches;
	}

	auto vsep = cpe.find(';');
	auto name = vsep == string::npos ? cpe : cpe.substr(0, vsep);

	sqlite3_bind_text(stmt, 1,  name.c_str(),         -1, nullptr);
	sqlite3_bind_text(stmt, 2, (name + ":%").c_str(), -1, nullptr);

	while (sqlite3_step(stmt) == SQLITE_ROW)
	{
		CveEntry ent;
		
		ent.cve      = string(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0)));
		ent.descr    = string(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 3)));
		ent.access   = string(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 5)));
		ent.date     = long(sqlite3_column_int64(stmt, 2));
		ent.severity = float(sqlite3_column_double(stmt, 4));

		matches.push_back(ent);
	}

	sqlite3_finalize(stmt);

	return matches;
}

unordered_map<string, vector<CveEntry>> VulnerabilityLookup::Scan(const vector<string>& cpes)
{
	unordered_map<string, vector<CveEntry>> matches;

	if ((db == nullptr && !openDatabase()) || cpes.size() == 0)
	{
		return matches;
	}

	for (auto& cpe : cpes)
	{
		if (cpe.empty() || count(cpe.begin(), cpe.end(), ':') < 3)
		{
			continue;
		}

		sqlite3_stmt *stmt;
		const char *err = nullptr;

		auto rc = sqlite3_prepare_v2(db, "select cve, cpe, date, descr, severity, access from affected join vulns on vulns.id = affected.vuln_id where cpe like ? or cpe like ? order by id desc", -1, &stmt, &err);

		if (rc != SQLITE_OK)
		{
			log(ERR, "Failed to prepare statement: " + string(err));

			delete err;
			continue;
		}

		auto vsep = cpe.find(';');
		auto name = vsep == string::npos ? cpe : cpe.substr(0, vsep);

		sqlite3_bind_text(stmt, 1,  name.c_str(),         -1, nullptr);
		sqlite3_bind_text(stmt, 2, (name + ":%").c_str(), -1, nullptr);

		while (sqlite3_step(stmt) == SQLITE_ROW)
		{
			CveEntry ent;

			ent.cve      = string(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0)));
			ent.descr    = string(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 3)));
			ent.access   = string(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 5)));
			ent.date     = long(sqlite3_column_int64(stmt, 2));
			ent.severity = float(sqlite3_column_double(stmt, 4));

			matches[cpe].push_back(ent);
		}

		sqlite3_finalize(stmt);
	}

	return matches;
}

bool VulnerabilityLookup::openDatabase()
{
	static mutex mtx;
	auto locked = mtx.try_lock();
	if (!locked)
	{
		// wait until running opener finishes before returning
		lock_guard<mutex> guard(mtx);
		return db != nullptr;
	}

	// open entries database

	string dbpath;
	string name = "cve-list";

	vector<string> paths = {
#if Windows
		get<0>(splitPath(getAppPath())) + "\\data\\" + name + ".db3",
		getEnvVar("APPDATA") + "\\RoliSoft\\Host Scanner\\data\\" + name + ".db3",
#else
		get<0>(splitPath(getAppPath())) + "/data/" + name + ".db3",
		"/var/lib/HostScanner/data/" + name + ".db3",
#endif
	};

	for (auto path : paths)
	{
		fs::path fp(path);

		if (!fs::exists(fp) || !fs::is_regular_file(fp))
		{
			continue;
		}

		dbpath = path;
	}

	if (dbpath.empty())
	{
		log(ERR, "Failed to locate CVE database.");

		mtx.unlock();
		return false;
	}

	auto rc = sqlite3_open(dbpath.c_str(), &db);

	if (rc != SQLITE_OK)
	{
		log(ERR, "Failed to open CVE database: " + string(sqlite3_errmsg(db)));

		sqlite3_close(db);
		db = nullptr;
	}

	// clean up

	mtx.unlock();

	return db != nullptr;
}

VulnerabilityLookup::~VulnerabilityLookup()
{
	if (db != nullptr)
	{
		sqlite3_close(db);
	}
}
